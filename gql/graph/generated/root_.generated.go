// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"
	"genos/internal/common/models"
	"sync/atomic"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Entity() EntityResolver
	Query() QueryResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	Entity struct {
		FindOrderByID func(childComplexity int, id int64) int
		FindUserByID  func(childComplexity int, id int64) int
	}

	Order struct {
		CreatedAt     func(childComplexity int) int
		DeletedAt     func(childComplexity int) int
		ID            func(childComplexity int) int
		OrderItems    func(childComplexity int) int
		OrderNumber   func(childComplexity int) int
		PaymentMethod func(childComplexity int) int
		Status        func(childComplexity int) int
		TotalAmount   func(childComplexity int) int
		UpdatedAt     func(childComplexity int) int
		UserID        func(childComplexity int) int
	}

	OrderItem struct {
		ID          func(childComplexity int) int
		OrderID     func(childComplexity int) int
		Price       func(childComplexity int) int
		ProductID   func(childComplexity int) int
		ProductName func(childComplexity int) int
		Qty         func(childComplexity int) int
	}

	Pagination struct {
		HasNext     func(childComplexity int) int
		HasPrevious func(childComplexity int) int
		Page        func(childComplexity int) int
		PerPage     func(childComplexity int) int
		TotalItems  func(childComplexity int) int
		TotalPages  func(childComplexity int) int
	}

	Query struct {
		GetOrder           func(childComplexity int, id int64) int
		GetOrderByUserID   func(childComplexity int, id int64, option *models.QueryOption) int
		__resolve__service func(childComplexity int) int
		__resolve_entities func(childComplexity int, representations []map[string]any) int
	}

	ResponseOrder struct {
		Items func(childComplexity int) int
	}

	ResponseOrderList struct {
		Items      func(childComplexity int) int
		Pagination func(childComplexity int) int
	}

	User struct {
		ID     func(childComplexity int) int
		Orders func(childComplexity int) int
	}

	_Service struct {
		SDL func(childComplexity int) int
	}
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(ctx context.Context, typeName, field string, childComplexity int, rawArgs map[string]any) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "Entity.findOrderByID":
		if e.complexity.Entity.FindOrderByID == nil {
			break
		}

		args, err := ec.field_Entity_findOrderByID_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Entity.FindOrderByID(childComplexity, args["id"].(int64)), true

	case "Entity.findUserByID":
		if e.complexity.Entity.FindUserByID == nil {
			break
		}

		args, err := ec.field_Entity_findUserByID_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Entity.FindUserByID(childComplexity, args["id"].(int64)), true

	case "Order.created_at":
		if e.complexity.Order.CreatedAt == nil {
			break
		}

		return e.complexity.Order.CreatedAt(childComplexity), true

	case "Order.deleted_at":
		if e.complexity.Order.DeletedAt == nil {
			break
		}

		return e.complexity.Order.DeletedAt(childComplexity), true

	case "Order.id":
		if e.complexity.Order.ID == nil {
			break
		}

		return e.complexity.Order.ID(childComplexity), true

	case "Order.order_items":
		if e.complexity.Order.OrderItems == nil {
			break
		}

		return e.complexity.Order.OrderItems(childComplexity), true

	case "Order.order_number":
		if e.complexity.Order.OrderNumber == nil {
			break
		}

		return e.complexity.Order.OrderNumber(childComplexity), true

	case "Order.payment_method":
		if e.complexity.Order.PaymentMethod == nil {
			break
		}

		return e.complexity.Order.PaymentMethod(childComplexity), true

	case "Order.status":
		if e.complexity.Order.Status == nil {
			break
		}

		return e.complexity.Order.Status(childComplexity), true

	case "Order.total_amount":
		if e.complexity.Order.TotalAmount == nil {
			break
		}

		return e.complexity.Order.TotalAmount(childComplexity), true

	case "Order.updated_at":
		if e.complexity.Order.UpdatedAt == nil {
			break
		}

		return e.complexity.Order.UpdatedAt(childComplexity), true

	case "Order.user_id":
		if e.complexity.Order.UserID == nil {
			break
		}

		return e.complexity.Order.UserID(childComplexity), true

	case "OrderItem.id":
		if e.complexity.OrderItem.ID == nil {
			break
		}

		return e.complexity.OrderItem.ID(childComplexity), true

	case "OrderItem.order_id":
		if e.complexity.OrderItem.OrderID == nil {
			break
		}

		return e.complexity.OrderItem.OrderID(childComplexity), true

	case "OrderItem.price":
		if e.complexity.OrderItem.Price == nil {
			break
		}

		return e.complexity.OrderItem.Price(childComplexity), true

	case "OrderItem.product_id":
		if e.complexity.OrderItem.ProductID == nil {
			break
		}

		return e.complexity.OrderItem.ProductID(childComplexity), true

	case "OrderItem.product_name":
		if e.complexity.OrderItem.ProductName == nil {
			break
		}

		return e.complexity.OrderItem.ProductName(childComplexity), true

	case "OrderItem.qty":
		if e.complexity.OrderItem.Qty == nil {
			break
		}

		return e.complexity.OrderItem.Qty(childComplexity), true

	case "Pagination.hasNext":
		if e.complexity.Pagination.HasNext == nil {
			break
		}

		return e.complexity.Pagination.HasNext(childComplexity), true

	case "Pagination.hasPrevious":
		if e.complexity.Pagination.HasPrevious == nil {
			break
		}

		return e.complexity.Pagination.HasPrevious(childComplexity), true

	case "Pagination.page":
		if e.complexity.Pagination.Page == nil {
			break
		}

		return e.complexity.Pagination.Page(childComplexity), true

	case "Pagination.perPage":
		if e.complexity.Pagination.PerPage == nil {
			break
		}

		return e.complexity.Pagination.PerPage(childComplexity), true

	case "Pagination.totalItems":
		if e.complexity.Pagination.TotalItems == nil {
			break
		}

		return e.complexity.Pagination.TotalItems(childComplexity), true

	case "Pagination.totalPages":
		if e.complexity.Pagination.TotalPages == nil {
			break
		}

		return e.complexity.Pagination.TotalPages(childComplexity), true

	case "Query.getOrder":
		if e.complexity.Query.GetOrder == nil {
			break
		}

		args, err := ec.field_Query_getOrder_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetOrder(childComplexity, args["id"].(int64)), true

	case "Query.getOrderByUserId":
		if e.complexity.Query.GetOrderByUserID == nil {
			break
		}

		args, err := ec.field_Query_getOrderByUserId_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetOrderByUserID(childComplexity, args["id"].(int64), args["option"].(*models.QueryOption)), true

	case "Query._service":
		if e.complexity.Query.__resolve__service == nil {
			break
		}

		return e.complexity.Query.__resolve__service(childComplexity), true

	case "Query._entities":
		if e.complexity.Query.__resolve_entities == nil {
			break
		}

		args, err := ec.field_Query__entities_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.__resolve_entities(childComplexity, args["representations"].([]map[string]any)), true

	case "ResponseOrder.items":
		if e.complexity.ResponseOrder.Items == nil {
			break
		}

		return e.complexity.ResponseOrder.Items(childComplexity), true

	case "ResponseOrderList.items":
		if e.complexity.ResponseOrderList.Items == nil {
			break
		}

		return e.complexity.ResponseOrderList.Items(childComplexity), true

	case "ResponseOrderList.pagination":
		if e.complexity.ResponseOrderList.Pagination == nil {
			break
		}

		return e.complexity.ResponseOrderList.Pagination(childComplexity), true

	case "User.id":
		if e.complexity.User.ID == nil {
			break
		}

		return e.complexity.User.ID(childComplexity), true

	case "User.orders":
		if e.complexity.User.Orders == nil {
			break
		}

		return e.complexity.User.Orders(childComplexity), true

	case "_Service.sdl":
		if e.complexity._Service.SDL == nil {
			break
		}

		return e.complexity._Service.SDL(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	opCtx := graphql.GetOperationContext(ctx)
	ec := executionContext{opCtx, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputExtraParams,
		ec.unmarshalInputFilter,
		ec.unmarshalInputQueryOption,
	)
	first := true

	switch opCtx.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, opCtx.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../schemas/master_schema.graphqls", Input: `scalar Int64
scalar Int8
scalar Time
scalar Any
scalar map



input QueryOption {
	condition: String
	page: Int
	limit: Int	
	order: String
	filter: [Filter]
	extraParams : [ExtraParams]
}

input Filter {
	key: String
	value: String
}

input ExtraParams {
	key: String
	value: Any
}

type Pagination {
	page: Int!
	totalPages: Int!
	totalItems: Int!
	perPage: Int!
	hasNext: Boolean!
	hasPrevious: Boolean!
}`, BuiltIn: false},
	{Name: "../schemas/order_schema.graphqls", Input: `# GraphQL schema 
# Define your types, queries, and mutations here.


type ResponseOrder {  
  items: Order!
}

type ResponseOrderList {  
  items: [Order]!
  pagination: Pagination!
}

extend type Query {
  getOrder(id: Int64!): ResponseOrder!
  getOrderByUserId(id: Int64!, option: QueryOption): ResponseOrderList!
}

type Order @key(fields: "id") {
  id: Int64!
  user_id: Int64!
  order_number: String!
  total_amount: Float!
  payment_method: String!
  status: String!
  created_at: Time!
  updated_at: Time!
  deleted_at: Time
  order_items: [OrderItem!]!
}

type OrderItem {
  id: Int64!
  order_id: Int64!
  product_id: Int64!
  product_name: String!
  qty: Int!
  price: Float!
}

extend type User @key(fields: "id") {
  id: Int64! @external
  orders: [Order!]!
}`, BuiltIn: false},
	{Name: "../../federation/directives.graphql", Input: `
	directive @authenticated on FIELD_DEFINITION | OBJECT | INTERFACE | SCALAR | ENUM
	directive @composeDirective(name: String!) repeatable on SCHEMA
	directive @extends on OBJECT | INTERFACE
	directive @external on OBJECT | FIELD_DEFINITION
	directive @key(fields: FieldSet!, resolvable: Boolean = true) repeatable on OBJECT | INTERFACE
	directive @inaccessible on
	  | ARGUMENT_DEFINITION
	  | ENUM
	  | ENUM_VALUE
	  | FIELD_DEFINITION
	  | INPUT_FIELD_DEFINITION
	  | INPUT_OBJECT
	  | INTERFACE
	  | OBJECT
	  | SCALAR
	  | UNION
	directive @interfaceObject on OBJECT
	directive @link(import: [String!], url: String!) repeatable on SCHEMA
	directive @override(from: String!, label: String) on FIELD_DEFINITION
	directive @policy(policies: [[federation__Policy!]!]!) on
	  | FIELD_DEFINITION
	  | OBJECT
	  | INTERFACE
	  | SCALAR
	  | ENUM
	directive @provides(fields: FieldSet!) on FIELD_DEFINITION
	directive @requires(fields: FieldSet!) on FIELD_DEFINITION
	directive @requiresScopes(scopes: [[federation__Scope!]!]!) on
	  | FIELD_DEFINITION
	  | OBJECT
	  | INTERFACE
	  | SCALAR
	  | ENUM
	directive @shareable repeatable on FIELD_DEFINITION | OBJECT
	directive @tag(name: String!) repeatable on
	  | ARGUMENT_DEFINITION
	  | ENUM
	  | ENUM_VALUE
	  | FIELD_DEFINITION
	  | INPUT_FIELD_DEFINITION
	  | INPUT_OBJECT
	  | INTERFACE
	  | OBJECT
	  | SCALAR
	  | UNION
	scalar _Any
	scalar FieldSet
	scalar federation__Policy
	scalar federation__Scope
`, BuiltIn: true},
	{Name: "../../federation/entity.graphql", Input: `
# a union of all types that use the @key directive
union _Entity = Order | User

# fake type to build resolver interfaces for users to implement
type Entity {
	findOrderByID(id: Int64!,): Order!
	findUserByID(id: Int64!,): User!
}

type _Service {
  sdl: String
}

extend type Query {
  _entities(representations: [_Any!]!): [_Entity]!
  _service: _Service!
}
`, BuiltIn: true},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)
