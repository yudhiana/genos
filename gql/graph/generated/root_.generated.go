// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"
	"genos/internal/common/models"
	"sync/atomic"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Order() OrderResolver
	OrderItem() OrderItemResolver
	Query() QueryResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	Order struct {
		OrderItems    func(childComplexity int) int
		PaymentMethod func(childComplexity int) int
		Status        func(childComplexity int) int
		UserID        func(childComplexity int) int
	}

	OrderItem struct {
		Price       func(childComplexity int) int
		ProductID   func(childComplexity int) int
		ProductName func(childComplexity int) int
		Qty         func(childComplexity int) int
	}

	Pagination struct {
		HasNext     func(childComplexity int) int
		HasPrevious func(childComplexity int) int
		Page        func(childComplexity int) int
		PerPage     func(childComplexity int) int
		TotalItems  func(childComplexity int) int
		TotalPages  func(childComplexity int) int
	}

	Query struct {
		GetOrder         func(childComplexity int, id int64) int
		GetOrderByUserID func(childComplexity int, option *models.QueryOption) int
	}

	ResponseOrder struct {
		Items func(childComplexity int) int
	}

	ResponseOrderList struct {
		Items      func(childComplexity int) int
		Pagination func(childComplexity int) int
	}
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(ctx context.Context, typeName, field string, childComplexity int, rawArgs map[string]any) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "Order.order_items":
		if e.complexity.Order.OrderItems == nil {
			break
		}

		return e.complexity.Order.OrderItems(childComplexity), true

	case "Order.payment_method":
		if e.complexity.Order.PaymentMethod == nil {
			break
		}

		return e.complexity.Order.PaymentMethod(childComplexity), true

	case "Order.status":
		if e.complexity.Order.Status == nil {
			break
		}

		return e.complexity.Order.Status(childComplexity), true

	case "Order.user_id":
		if e.complexity.Order.UserID == nil {
			break
		}

		return e.complexity.Order.UserID(childComplexity), true

	case "OrderItem.price":
		if e.complexity.OrderItem.Price == nil {
			break
		}

		return e.complexity.OrderItem.Price(childComplexity), true

	case "OrderItem.product_id":
		if e.complexity.OrderItem.ProductID == nil {
			break
		}

		return e.complexity.OrderItem.ProductID(childComplexity), true

	case "OrderItem.product_name":
		if e.complexity.OrderItem.ProductName == nil {
			break
		}

		return e.complexity.OrderItem.ProductName(childComplexity), true

	case "OrderItem.qty":
		if e.complexity.OrderItem.Qty == nil {
			break
		}

		return e.complexity.OrderItem.Qty(childComplexity), true

	case "Pagination.hasNext":
		if e.complexity.Pagination.HasNext == nil {
			break
		}

		return e.complexity.Pagination.HasNext(childComplexity), true

	case "Pagination.hasPrevious":
		if e.complexity.Pagination.HasPrevious == nil {
			break
		}

		return e.complexity.Pagination.HasPrevious(childComplexity), true

	case "Pagination.page":
		if e.complexity.Pagination.Page == nil {
			break
		}

		return e.complexity.Pagination.Page(childComplexity), true

	case "Pagination.perPage":
		if e.complexity.Pagination.PerPage == nil {
			break
		}

		return e.complexity.Pagination.PerPage(childComplexity), true

	case "Pagination.totalItems":
		if e.complexity.Pagination.TotalItems == nil {
			break
		}

		return e.complexity.Pagination.TotalItems(childComplexity), true

	case "Pagination.totalPages":
		if e.complexity.Pagination.TotalPages == nil {
			break
		}

		return e.complexity.Pagination.TotalPages(childComplexity), true

	case "Query.getOrder":
		if e.complexity.Query.GetOrder == nil {
			break
		}

		args, err := ec.field_Query_getOrder_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetOrder(childComplexity, args["id"].(int64)), true

	case "Query.getOrderByUserId":
		if e.complexity.Query.GetOrderByUserID == nil {
			break
		}

		args, err := ec.field_Query_getOrderByUserId_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetOrderByUserID(childComplexity, args["option"].(*models.QueryOption)), true

	case "ResponseOrder.items":
		if e.complexity.ResponseOrder.Items == nil {
			break
		}

		return e.complexity.ResponseOrder.Items(childComplexity), true

	case "ResponseOrderList.items":
		if e.complexity.ResponseOrderList.Items == nil {
			break
		}

		return e.complexity.ResponseOrderList.Items(childComplexity), true

	case "ResponseOrderList.pagination":
		if e.complexity.ResponseOrderList.Pagination == nil {
			break
		}

		return e.complexity.ResponseOrderList.Pagination(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	opCtx := graphql.GetOperationContext(ctx)
	ec := executionContext{opCtx, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputExtraParams,
		ec.unmarshalInputFilter,
		ec.unmarshalInputQueryOption,
	)
	first := true

	switch opCtx.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, opCtx.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../schemas/master_schema.graphqls", Input: `scalar Int64
scalar Int8
scalar Time
scalar Any
scalar map



input QueryOption {
	condition: String
	page: Int
	limit: Int	
	order: String
	filter: [Filter]
	extraParams : [ExtraParams]
}

input Filter {
	key: String
	value: String
}

input ExtraParams {
	key: String
	value: Any
}

type Pagination {
	page: Int!
	totalPages: Int!
	totalItems: Int!
	perPage: Int!
	hasNext: Boolean!
	hasPrevious: Boolean!
}`, BuiltIn: false},
	{Name: "../schemas/order_schema.graphqls", Input: `# GraphQL schema 
# Define your types, queries, and mutations here.

type ResponseOrder {  
  items: Order!
}

type ResponseOrderList {  
  items: [Order]!
  pagination: Pagination!
}

extend type Query {
  getOrder(id: Int64!): ResponseOrder!
  getOrderByUserId(option: QueryOption): ResponseOrderList!
}

type OrderItem {
  product_id: Int64!
  product_name: String!
  qty: Int!
  price: Float!
}

type Order {
  user_id: Int64!
  payment_method: String!
  status: String!
  order_items: [OrderItem]!
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)
